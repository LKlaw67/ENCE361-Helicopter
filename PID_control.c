/*
 * PID_control.c
 *
 *  Created on: 5/05/2024
 *      Author: Lucas
 */
#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "inc/hw_ints.h"
#include "inc/hw_types.h"
#include "driverlib/pwm.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/debug.h"
#include "utils/ustdlib.h"
#include "PID_control.h"

//max and min outputs for rotors
#define TAIL_OUTPUT_MAX 75
#define TAIL_OUTPUT_MIN 3
#define MAIN_OUTPUT_MAX 80
#define MAIN_OUTPUT_MIN 15

//Gains for Heli rig

#define MAIN_KP 50
#define MAIN_KI 19
#define MAIN_KD 17

#define TAIL_KP 300
#define TAIL_KI 50
#define TAIL_KD 14


//Gains for simulator
/*
#define MAIN_KP 250
#define MAIN_KI 22
#define MAIN_KD 100

#define TAIL_KP 450
#define TAIL_KI 15
#define TAIL_KD 150*/

//accounts for gravity on helicopter
#define K_GRAVITY 33
//accounts for the moment generated by the main rotor
//is proportiona to main duty cycle
#define K_COUPLING 8

//the number of steps in the encoder
//112 lines, 4 states
#define HALF_TOTAL_STEPS (112*2)
#define TOTAL_STEPS (112*4)

//clock divider for pwm
#define PWM_DIVIDER_CODE SYSCTL_PWMDIV_4
#define PWM_DIVIDER 4

//main rotor pwm definitions
#define PWM_MAIN_BASE        PWM0_BASE
#define PWM_MAIN_GEN         PWM_GEN_3
#define PWM_MAIN_OUTNUM      PWM_OUT_7
#define PWM_MAIN_OUTBIT      PWM_OUT_7_BIT
#define PWM_MAIN_PERIPH_PWM  SYSCTL_PERIPH_PWM0
#define PWM_MAIN_PERIPH_GPIO SYSCTL_PERIPH_GPIOC
#define PWM_MAIN_GPIO_BASE   GPIO_PORTC_BASE
#define PWM_MAIN_GPIO_CONFIG GPIO_PC5_M0PWM7
#define PWM_MAIN_GPIO_PIN    GPIO_PIN_5
#define PWM_MAIN_RATE_HZ 200

//tail rotor pwm definitions
#define PWM_TAIL_BASE        PWM1_BASE
#define PWM_TAIL_GEN         PWM_GEN_2
#define PWM_TAIL_OUTNUM      PWM_OUT_5
#define PWM_TAIL_OUTBIT      PWM_OUT_5_BIT
#define PWM_TAIL_PERIPH_PWM  SYSCTL_PERIPH_PWM1
#define PWM_TAIL_PERIPH_GPIO SYSCTL_PERIPH_GPIOF
#define PWM_TAIL_GPIO_BASE   GPIO_PORTF_BASE
#define PWM_TAIL_GPIO_CONFIG GPIO_PF1_M1PWM5
#define PWM_TAIL_GPIO_PIN    GPIO_PIN_1
#define PWM_TAIL_RATE_HZ 200

//change in time for derivative
//default set at 60, changed in initialisation
static uint8_t delta_t = 60;

//structs for rotors
PID mainPID, tailPID;

//sets main rotor intergral sum to zero
void eraseMainIntegral() {
    mainPID.I = 0;
}

//sets tail rotor intergral sum to zero
void eraseTailIntegral() {
    tailPID.I = 0;
}

//Configures PWM for main Rotor
void setMainPWM(int32_t DutyCycle)
{
    uint32_t Period = SysCtlClockGet() / PWM_DIVIDER / PWM_MAIN_RATE_HZ;

    PWMGenPeriodSet(PWM_MAIN_BASE, PWM_MAIN_GEN, Period);
    PWMPulseWidthSet(PWM_MAIN_BASE, PWM_MAIN_OUTNUM, Period * DutyCycle / 100);
}

//Configures PWM for Tail Rotor
void setTailPWM(int32_t DutyCycle)
{
    uint32_t Period = SysCtlClockGet() / PWM_DIVIDER / PWM_TAIL_RATE_HZ;

    PWMGenPeriodSet(PWM_TAIL_BASE, PWM_TAIL_GEN, Period);
    PWMPulseWidthSet(PWM_TAIL_BASE, PWM_TAIL_OUTNUM, Period * DutyCycle / 100);
}

//enables or disables main rotor PWM
void MainPWMEnable(uint8_t enable)
{
    PWMOutputState(PWM_MAIN_BASE, PWM_MAIN_OUTBIT, enable);
}
//enables or disables tail rotor PWM
void TailPWMEnable(uint8_t enable)
{
    PWMOutputState(PWM_TAIL_BASE, PWM_TAIL_OUTBIT, enable);
}

//Sets original values for gains, enables reseting and links to ports for main rotor
void initMainPWM()
{
    mainPID.setpoint = 0;
    mainPID.reading = 0;
    mainPID.prev_reading = 0;
    mainPID.Kp = MAIN_KP;
    mainPID.Ki = MAIN_KI;
    mainPID.Kd = MAIN_KD;
    mainPID.I = 0;
    mainPID.duty_cycle = 0;

    SysCtlPeripheralReset(PWM_MAIN_PERIPH_PWM);//resets PWM for saftey
    SysCtlPeripheralReset(PWM_MAIN_PERIPH_GPIO);//resets GPIO for saftey
    SysCtlPeripheralEnable(PWM_MAIN_PERIPH_PWM);//enables PWm
    SysCtlPeripheralEnable(PWM_MAIN_PERIPH_GPIO);//enables GPIO

    GPIOPinConfigure(PWM_MAIN_GPIO_CONFIG);//configures PWM
    GPIOPinTypePWM(PWM_MAIN_GPIO_BASE, PWM_MAIN_GPIO_PIN);

    PWMGenConfigure(PWM_MAIN_BASE, PWM_MAIN_GEN, PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);
    PWMGenEnable(PWM_MAIN_BASE, PWM_MAIN_GEN);
}

//Sets original values for gains, enables reseting and links to ports for tail rotor
void initTailPWM()
{
    tailPID.setpoint = 0;
    tailPID.reading = 0;
    tailPID.prev_reading = 0;
    tailPID.Kp = TAIL_KP;
    tailPID.Ki = TAIL_KI;
    tailPID.Kd = TAIL_KD;
    tailPID.I = 0;
    tailPID.duty_cycle = 0;

    SysCtlPeripheralReset(PWM_TAIL_PERIPH_PWM);//resets PWM for saftey
    SysCtlPeripheralReset(PWM_TAIL_PERIPH_GPIO);//resets GPIO for saftey
    SysCtlPeripheralEnable(PWM_TAIL_PERIPH_PWM);//enables PWM
    SysCtlPeripheralEnable(PWM_TAIL_PERIPH_GPIO);//enables GPIO

    GPIOPinTypePWM(PWM_TAIL_GPIO_BASE, PWM_TAIL_GPIO_PIN);//configures PWM
    GPIOPinConfigure(PWM_TAIL_GPIO_CONFIG);

    PWMGenConfigure(PWM_TAIL_BASE, PWM_TAIL_GEN, PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);
    PWMGenEnable(PWM_TAIL_BASE, PWM_TAIL_GEN);
}

//enables PID
void initPID(uint8_t frequency)
{
    delta_t = frequency;
    SysCtlPWMClockSet(PWM_DIVIDER_CODE);//sets clock divider value

    initMainPWM();//initialises PWM
    initTailPWM();
    MainPWMEnable(0);
    TailPWMEnable(0);
}

//Updates PID
void PIDUpdate(PID* pid)
{
    int16_t error = 0;
    int32_t P = 0;
    int32_t D = 0;
    int32_t dI = 0;

    //Finds error for PID control
    error = pid->setpoint - pid->reading;
    P = pid->Kp * error;
    dI = pid->Ki * error / delta_t;
    D = pid->Kd * (pid->prev_reading - pid->reading) * delta_t;

    //adds all and scales by 1000 for increased precision
    pid->duty_cycle = (P + (pid->I + dI) + D)/1000;

    pid->I += dI;
    pid->prev_reading = pid->reading;
}

//Reads and updates main rotor
void updateMainRotor(int16_t altitude)
{
    mainPID.reading = altitude;
    PIDUpdate(&mainPID);
    mainPID.duty_cycle += K_GRAVITY;

    //Makes sure rotor cannot go too fast
    if (mainPID.duty_cycle > MAIN_OUTPUT_MAX) {
        mainPID.duty_cycle = MAIN_OUTPUT_MAX;
    } else if (mainPID.duty_cycle < MAIN_OUTPUT_MIN) {
        mainPID.duty_cycle = MAIN_OUTPUT_MIN;
    }
}

//Reads and updates tail rotor yaw
void updateTailRotor(int16_t yaw)
{
    tailPID.reading = yaw;
    //ensures wrap around works correctly so yaw works correctly
    if(tailPID.reading - tailPID.setpoint >= HALF_TOTAL_STEPS) {
        tailPID.reading -= TOTAL_STEPS;
    } else if(tailPID.setpoint - tailPID.reading >= HALF_TOTAL_STEPS) {
        tailPID.reading += TOTAL_STEPS;
    }
    PIDUpdate(&tailPID);
    tailPID.duty_cycle += (K_COUPLING*mainPID.duty_cycle/10);

    //Makes sure rotor cannot go too fast
    if (tailPID.duty_cycle > TAIL_OUTPUT_MAX) {
        tailPID.duty_cycle = TAIL_OUTPUT_MAX;
    } else if (tailPID.duty_cycle < TAIL_OUTPUT_MIN) {
        tailPID.duty_cycle = TAIL_OUTPUT_MIN;
    }
}

//updates both rotors
void updateRotors(int16_t altitude, int16_t yaw)
{
    updateMainRotor(altitude);
    updateTailRotor(yaw);
    setTailPWM(tailPID.duty_cycle);
    setMainPWM(mainPID.duty_cycle);
}

//sets altitude
void setAltitude(int16_t altitude)
{
    mainPID.setpoint = altitude;
}

//gets main rotors duty cycle
uint16_t getMainDutyCycle()
{
    return mainPID.duty_cycle;
}

//gets tail rotors duty cycle
uint16_t getTailDutyCycle()
{
    return tailPID.duty_cycle;
}

//sets yaw
void setYaw(int16_t yaw)
{
    tailPID.setpoint = yaw;
}
